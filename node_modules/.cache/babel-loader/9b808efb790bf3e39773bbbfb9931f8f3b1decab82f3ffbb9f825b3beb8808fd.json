{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@aws-sdk/service-error-classification\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = options => (next, context) => async args => {\n  let retryStrategy = await options.retryStrategy();\n  const maxAttempts = await options.maxAttempts();\n  if (isRetryStrategyV2(retryStrategy)) {\n    retryStrategy = retryStrategy;\n    let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n    let lastError = new Error();\n    let attempts = 0;\n    let totalRetryDelay = 0;\n    const {\n      request\n    } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        retryStrategy.recordSuccess(retryToken);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalRetryDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const retryErrorInfo = getRetyErrorInto(e);\n        lastError = asSdkError(e);\n        try {\n          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n        } catch (refreshError) {\n          if (!lastError.$metadata) {\n            lastError.$metadata = {};\n          }\n          lastError.$metadata.attempts = attempts + 1;\n          lastError.$metadata.totalRetryDelay = totalRetryDelay;\n          throw lastError;\n        }\n        attempts = retryToken.getRetryCount();\n        const delay = retryToken.getRetryDelay();\n        totalRetryDelay += delay;\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  } else {\n    retryStrategy = retryStrategy;\n    if (retryStrategy?.mode) context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n    return retryStrategy.retry(next, args);\n  }\n};\nconst isRetryStrategyV2 = retryStrategy => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" && typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" && typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetyErrorInto = error => {\n  const errorInfo = {\n    errorType: getRetryErrorType(error)\n  };\n  const retryAfterHint = getRetryAfterHint(error.$response);\n  if (retryAfterHint) {\n    errorInfo.retryAfterHint = retryAfterHint;\n  }\n  return errorInfo;\n};\nconst getRetryErrorType = error => {\n  if (isThrottlingError(error)) return \"THROTTLING\";\n  if (isTransientError(error)) return \"TRANSIENT\";\n  if (isServerError(error)) return \"SERVER_ERROR\";\n  return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override: true\n};\nexport const getRetryPlugin = options => ({\n  applyToStack: clientStack => {\n    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n  }\n});\nexport const getRetryAfterHint = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate;\n};","map":{"version":3,"names":["HttpRequest","HttpResponse","isServerError","isThrottlingError","isTransientError","INVOCATION_ID_HEADER","REQUEST_HEADER","v4","asSdkError","retryMiddleware","options","next","context","args","retryStrategy","maxAttempts","isRetryStrategyV2","retryToken","acquireInitialRetryToken","lastError","Error","attempts","totalRetryDelay","request","isInstance","headers","response","output","recordSuccess","$metadata","e","retryErrorInfo","getRetyErrorInto","refreshRetryTokenForRetry","refreshError","getRetryCount","delay","getRetryDelay","Promise","resolve","setTimeout","mode","userAgent","retry","error","errorInfo","errorType","getRetryErrorType","retryAfterHint","getRetryAfterHint","$response","retryMiddlewareOptions","name","tags","step","priority","override","getRetryPlugin","applyToStack","clientStack","add","retryAfterHeaderName","Object","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","Date","retryAfterDate"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js"],"sourcesContent":["import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@aws-sdk/service-error-classification\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = (options) => (next, context) => async (args) => {\n    let retryStrategy = await options.retryStrategy();\n    const maxAttempts = await options.maxAttempts();\n    if (isRetryStrategyV2(retryStrategy)) {\n        retryStrategy = retryStrategy;\n        let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n        let lastError = new Error();\n        let attempts = 0;\n        let totalRetryDelay = 0;\n        const { request } = args;\n        if (HttpRequest.isInstance(request)) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (HttpRequest.isInstance(request)) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                const { response, output } = await next(args);\n                retryStrategy.recordSuccess(retryToken);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalRetryDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const retryErrorInfo = getRetyErrorInto(e);\n                lastError = asSdkError(e);\n                try {\n                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n                }\n                catch (refreshError) {\n                    if (!lastError.$metadata) {\n                        lastError.$metadata = {};\n                    }\n                    lastError.$metadata.attempts = attempts + 1;\n                    lastError.$metadata.totalRetryDelay = totalRetryDelay;\n                    throw lastError;\n                }\n                attempts = retryToken.getRetryCount();\n                const delay = retryToken.getRetryDelay();\n                totalRetryDelay += delay;\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n    }\n    else {\n        retryStrategy = retryStrategy;\n        if (retryStrategy?.mode)\n            context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n        return retryStrategy.retry(next, args);\n    }\n};\nconst isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" &&\n    typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" &&\n    typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetyErrorInto = (error) => {\n    const errorInfo = {\n        errorType: getRetryErrorType(error),\n    };\n    const retryAfterHint = getRetryAfterHint(error.$response);\n    if (retryAfterHint) {\n        errorInfo.retryAfterHint = retryAfterHint;\n    }\n    return errorInfo;\n};\nconst getRetryErrorType = (error) => {\n    if (isThrottlingError(error))\n        return \"THROTTLING\";\n    if (isTransientError(error))\n        return \"TRANSIENT\";\n    if (isServerError(error))\n        return \"SERVER_ERROR\";\n    return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n    name: \"retryMiddleware\",\n    tags: [\"RETRY\"],\n    step: \"finalizeRequest\",\n    priority: \"high\",\n    override: true,\n};\nexport const getRetryPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n    },\n});\nexport const getRetryAfterHint = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return new Date(retryAfterSeconds * 1000);\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}