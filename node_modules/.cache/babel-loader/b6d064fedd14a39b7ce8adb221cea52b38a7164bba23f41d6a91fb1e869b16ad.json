{"ast":null,"code":"import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttemptsProvider) {\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n    this.maxAttemptsProvider = maxAttemptsProvider;\n  }\n  async acquireInitialRetryToken(retryTokenScope) {\n    return this.retryToken;\n  }\n  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n    const maxAttempts = await this.getMaxAttempts();\n    if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n      tokenToRenew.getRetryTokenCount(errorInfo);\n      return tokenToRenew;\n    }\n    throw new Error(\"No retry token available\");\n  }\n  recordSuccess(token) {\n    this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      return await this.maxAttemptsProvider();\n    } catch (error) {\n      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n      return DEFAULT_MAX_ATTEMPTS;\n    }\n  }\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount();\n    return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n}","map":{"version":3,"names":["DEFAULT_MAX_ATTEMPTS","RETRY_MODES","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","getDefaultRetryToken","StandardRetryStrategy","constructor","maxAttemptsProvider","mode","STANDARD","retryToken","acquireInitialRetryToken","retryTokenScope","refreshRetryTokenForRetry","tokenToRenew","errorInfo","maxAttempts","getMaxAttempts","shouldRetry","getRetryTokenCount","Error","recordSuccess","token","releaseRetryTokens","getLastRetryCost","error","console","warn","attempts","getRetryCount","hasRetryTokens","errorType","isRetryableError"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    constructor(maxAttemptsProvider) {\n        this.maxAttemptsProvider = maxAttemptsProvider;\n        this.mode = RETRY_MODES.STANDARD;\n        this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n        this.maxAttemptsProvider = maxAttemptsProvider;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return this.retryToken;\n    }\n    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n            tokenToRenew.getRetryTokenCount(errorInfo);\n            return tokenToRenew;\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n    }\n    async getMaxAttempts() {\n        let maxAttempts;\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount();\n        return (attempts < maxAttempts &&\n            tokenToRenew.hasRetryTokens(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n"],"mappings":"AAAA,SAASA,oBAAoB,EAAEC,WAAW,QAAQ,UAAU;AAC5D,SAASC,wBAAwB,EAAEC,oBAAoB,QAAQ,aAAa;AAC5E,SAASC,oBAAoB,QAAQ,qBAAqB;AAC1D,OAAO,MAAMC,qBAAqB,CAAC;EAC/BC,WAAW,CAACC,mBAAmB,EAAE;IAC7B,IAAI,CAACA,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,IAAI,GAAGP,WAAW,CAACQ,QAAQ;IAChC,IAAI,CAACC,UAAU,GAAGN,oBAAoB,CAACD,oBAAoB,EAAED,wBAAwB,CAAC;IACtF,IAAI,CAACK,mBAAmB,GAAGA,mBAAmB;EAClD;EACA,MAAMI,wBAAwB,CAACC,eAAe,EAAE;IAC5C,OAAO,IAAI,CAACF,UAAU;EAC1B;EACA,MAAMG,yBAAyB,CAACC,YAAY,EAAEC,SAAS,EAAE;IACrD,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACC,cAAc,EAAE;IAC/C,IAAI,IAAI,CAACC,WAAW,CAACJ,YAAY,EAAEC,SAAS,EAAEC,WAAW,CAAC,EAAE;MACxDF,YAAY,CAACK,kBAAkB,CAACJ,SAAS,CAAC;MAC1C,OAAOD,YAAY;IACvB;IACA,MAAM,IAAIM,KAAK,CAAC,0BAA0B,CAAC;EAC/C;EACAC,aAAa,CAACC,KAAK,EAAE;IACjB,IAAI,CAACZ,UAAU,CAACa,kBAAkB,CAACD,KAAK,CAACE,gBAAgB,EAAE,CAAC;EAChE;EACA,MAAMP,cAAc,GAAG;IACnB,IAAID,WAAW;IACf,IAAI;MACA,OAAO,MAAM,IAAI,CAACT,mBAAmB,EAAE;IAC3C,CAAC,CACD,OAAOkB,KAAK,EAAE;MACVC,OAAO,CAACC,IAAI,CAAE,6DAA4D3B,oBAAqB,EAAC,CAAC;MACjG,OAAOA,oBAAoB;IAC/B;EACJ;EACAkB,WAAW,CAACJ,YAAY,EAAEC,SAAS,EAAEC,WAAW,EAAE;IAC9C,MAAMY,QAAQ,GAAGd,YAAY,CAACe,aAAa,EAAE;IAC7C,OAAQD,QAAQ,GAAGZ,WAAW,IAC1BF,YAAY,CAACgB,cAAc,CAACf,SAAS,CAACgB,SAAS,CAAC,IAChD,IAAI,CAACC,gBAAgB,CAACjB,SAAS,CAACgB,SAAS,CAAC;EAClD;EACAC,gBAAgB,CAACD,SAAS,EAAE;IACxB,OAAOA,SAAS,KAAK,YAAY,IAAIA,SAAS,KAAK,WAAW;EAClE;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}