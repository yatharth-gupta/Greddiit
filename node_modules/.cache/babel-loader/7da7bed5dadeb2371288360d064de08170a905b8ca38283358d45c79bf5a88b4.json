{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, RETRY_MODES, THROTTLING_RETRY_DELAY_BASE } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { asSdkError } from \"./util\";\nexport class StandardRetryStrategy {\n  constructor(maxAttemptsProvider, options) {\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n    this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n    this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n  shouldRetry(error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      maxAttempts = await this.maxAttemptsProvider();\n    } catch (error) {\n      maxAttempts = DEFAULT_MAX_ATTEMPTS;\n    }\n    return maxAttempts;\n  }\n  async retry(next, args, options) {\n    let retryTokenAmount;\n    let attempts = 0;\n    let totalDelay = 0;\n    const maxAttempts = await this.getMaxAttempts();\n    const {\n      request\n    } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        if (options?.beforeRequest) {\n          await options.beforeRequest();\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        if (options?.afterRequest) {\n          options.afterRequest(response);\n        }\n        this.retryQuota.releaseRetryTokens(retryTokenAmount);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const err = asSdkError(e);\n        attempts++;\n        if (this.shouldRetry(err, attempts, maxAttempts)) {\n          retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n          const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n          const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n          const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n          totalDelay += delay;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n        err.$metadata.attempts = attempts;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\nconst getDelayFromRetryAfterHeader = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate.getTime() - Date.now();\n};","map":{"version":3,"names":["HttpRequest","HttpResponse","isThrottlingError","DEFAULT_MAX_ATTEMPTS","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","INVOCATION_ID_HEADER","REQUEST_HEADER","RETRY_MODES","THROTTLING_RETRY_DELAY_BASE","v4","getDefaultRetryQuota","defaultDelayDecider","defaultRetryDecider","asSdkError","StandardRetryStrategy","constructor","maxAttemptsProvider","options","mode","STANDARD","retryDecider","delayDecider","retryQuota","shouldRetry","error","attempts","maxAttempts","hasRetryTokens","getMaxAttempts","retry","next","args","retryTokenAmount","totalDelay","request","isInstance","headers","beforeRequest","response","output","afterRequest","releaseRetryTokens","$metadata","totalRetryDelay","e","err","retrieveRetryTokens","delayFromDecider","delayFromResponse","getDelayFromRetryAfterHeader","$response","delay","Math","max","Promise","resolve","setTimeout","retryAfterHeaderName","Object","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","retryAfterDate","Date","getTime","now"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/@aws-sdk/middleware-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, RETRY_MODES, THROTTLING_RETRY_DELAY_BASE, } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { asSdkError } from \"./util\";\nexport class StandardRetryStrategy {\n    constructor(maxAttemptsProvider, options) {\n        this.maxAttemptsProvider = maxAttemptsProvider;\n        this.mode = RETRY_MODES.STANDARD;\n        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n    }\n    shouldRetry(error, attempts, maxAttempts) {\n        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n    }\n    async getMaxAttempts() {\n        let maxAttempts;\n        try {\n            maxAttempts = await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            maxAttempts = DEFAULT_MAX_ATTEMPTS;\n        }\n        return maxAttempts;\n    }\n    async retry(next, args, options) {\n        let retryTokenAmount;\n        let attempts = 0;\n        let totalDelay = 0;\n        const maxAttempts = await this.getMaxAttempts();\n        const { request } = args;\n        if (HttpRequest.isInstance(request)) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (HttpRequest.isInstance(request)) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                if (options?.beforeRequest) {\n                    await options.beforeRequest();\n                }\n                const { response, output } = await next(args);\n                if (options?.afterRequest) {\n                    options.afterRequest(response);\n                }\n                this.retryQuota.releaseRetryTokens(retryTokenAmount);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const err = asSdkError(e);\n                attempts++;\n                if (this.shouldRetry(err, attempts, maxAttempts)) {\n                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n                    const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n                    totalDelay += delay;\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                    continue;\n                }\n                if (!err.$metadata) {\n                    err.$metadata = {};\n                }\n                err.$metadata.attempts = attempts;\n                err.$metadata.totalRetryDelay = totalDelay;\n                throw err;\n            }\n        }\n    }\n}\nconst getDelayFromRetryAfterHeader = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return retryAfterSeconds * 1000;\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate.getTime() - Date.now();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}