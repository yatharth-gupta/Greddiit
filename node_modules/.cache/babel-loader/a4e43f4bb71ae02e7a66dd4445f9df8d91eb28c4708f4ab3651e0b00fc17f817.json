{"ast":null,"code":"const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n  return arrToStr(jArray, options, \"\", 0);\n}\nfunction arrToStr(arr, options, jPath, level) {\n  let xmlStr = \"\";\n  let indentation = \"\";\n  if (options.format && options.indentBy.length > 0) {\n    //TODO: this logic can be avoided for each call\n    indentation = EOL + \"\" + options.indentBy.repeat(level);\n  }\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const tagName = propName(tagObj);\n    let newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = `${jPath}.${tagName}`;\n    if (tagName === options.textNodeName) {\n      let tagText = tagObj[tagName];\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n      xmlStr += indentation + tagText;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n      continue;\n    } else if (tagName[0] === \"?\") {\n      const attStr = attr_to_str(tagObj[\":@\"], options);\n      const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n      let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n      piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n      continue;\n    }\n    const attStr = attr_to_str(tagObj[\":@\"], options);\n    let tagStart = indentation + `<${tagName}${attStr}`;\n    let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else {\n      //TODO: node with only text value should not parse the text value in next line\n      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n    }\n  }\n  return xmlStr;\n}\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== \":@\") return key;\n  }\n}\nfunction attr_to_str(attrMap, options) {\n  let attrStr = \"\";\n  if (attrMap && !options.ignoreAttributes) {\n    for (let attr in attrMap) {\n      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n      } else {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n      }\n    }\n  }\n  return attrStr;\n}\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n  for (let index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n  return false;\n}\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (let i = 0; i < options.entities.length; i++) {\n      const entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\nmodule.exports = toXml;","map":{"version":3,"names":["EOL","toXml","jArray","options","arrToStr","arr","jPath","level","xmlStr","indentation","format","indentBy","length","repeat","i","tagObj","tagName","propName","newJPath","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tempInd","piTextNodeName","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","obj","keys","Object","key","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options){\n    return arrToStr( jArray, options, \"\", 0);\n}\n\nfunction arrToStr(arr, options, jPath, level){\n    let xmlStr = \"\";\n\n    let indentation = \"\";\n    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call\n        indentation = EOL + \"\" + options.indentBy.repeat(level);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if(jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if(tagName === options.textNodeName){\n            let tagText = tagObj[tagName];\n            if(!isStopNode(newJPath, options)){\n                tagText = options.tagValueProcessor( tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            xmlStr += indentation + tagText;\n            continue;\n        }else if( tagName === options.cdataPropName){\n            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            continue;\n        }else if( tagName === options.commentPropName){\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            continue;\n        }else if( tagName[0] === \"?\"){\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            continue;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        let tagStart =  indentation + `<${tagName}${attStr}`;\n        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\n        if(options.unpairedTags.indexOf(tagName) !== -1){\n            if(options.suppressUnpairedNode)  xmlStr += tagStart + \">\"; \n            else xmlStr += tagStart + \"/>\"; \n        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ \n            xmlStr += tagStart + \"/>\"; \n        }else{ \n            //TODO: node with only text value should not parse the text value in next line\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;\n        }\n    }\n    \n    return xmlStr;\n}\n\nfunction propName(obj){\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if(key !== \":@\") return key;\n    }\n  }\n\nfunction attr_to_str(attrMap, options){\n    let attrStr = \"\";\n    if(attrMap && !options.ignoreAttributes){\n        for (let attr in attrMap){\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if(attrVal === true && options.suppressBooleanAttributes){\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            }else{\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options){\n    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for(let index in options.stopNodes){\n        if(options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\"+tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options){\n    if(textValue && textValue.length > 0 && options.processEntities){\n      for (let i=0; i< options.entities.length; i++) {\n        const entity = options.entities[i];\n        textValue = textValue.replace(entity.regex, entity.val);\n      }\n    }\n    return textValue;\n  }\nmodule.exports = toXml;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}