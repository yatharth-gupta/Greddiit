{"ast":null,"code":"'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options) {\n  return compress(node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath) {\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if (jPath === undefined) newJpath = property;else newJpath = jPath + \".\" + property;\n    if (property === options.textNodeName) {\n      if (text === undefined) text = tagObj[property];else text += \"\" + tagObj[property];\n    } else if (property === undefined) {\n      continue;\n    } else if (tagObj[property]) {\n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n      if (tagObj[\":@\"]) {\n        assignAttributes(val, tagObj[\":@\"], newJpath, options);\n      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {\n        val = val[options.textNodeName];\n      } else if (Object.keys(val).length === 0) {\n        if (options.alwaysCreateTextNode) val[options.textNodeName] = \"\";else val = \"\";\n      }\n      if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if (!Array.isArray(compressedObj[property])) {\n          compressedObj[property] = [compressedObj[property]];\n        }\n        compressedObj[property].push(val);\n      } else {\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf)) {\n          compressedObj[property] = [val];\n        } else {\n          compressedObj[property] = val;\n        }\n      }\n    }\n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if (typeof text === \"string\") {\n    if (text.length > 0) compressedObj[options.textNodeName] = text;\n  } else if (text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== \":@\") return key;\n  }\n}\nfunction assignAttributes(obj, attrMap, jpath, options) {\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [attrMap[atrrName]];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\nfunction isLeafTag(obj, options) {\n  const propCount = Object.keys(obj).length;\n  if (propCount === 0 || propCount === 1 && obj[options.textNodeName]) return true;\n  return false;\n}\nexports.prettify = prettify;","map":{"version":3,"names":["prettify","node","options","compress","arr","jPath","text","compressedObj","i","length","tagObj","property","propName","newJpath","undefined","textNodeName","val","isLeaf","isLeafTag","assignAttributes","Object","keys","alwaysCreateTextNode","hasOwnProperty","Array","isArray","push","obj","key","attrMap","jpath","len","atrrName","propCount","exports"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/fast-xml-parser/src/xmlparser/node2json.js"],"sourcesContent":["'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const propCount = Object.keys(obj).length;\n  if( propCount === 0 || (propCount === 1 && obj[options.textNodeName]) ) return true;\n  return false;\n}\nexports.prettify = prettify;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}