{"ast":null,"code":"import { debugId, toDebugString } from \"./debug\";\nimport { EndpointError } from \"./types\";\nimport { evaluateRules } from \"./utils\";\nexport const resolveEndpoint = (ruleSetObject, options) => {\n  const {\n    endpointParams,\n    logger\n  } = options;\n  const {\n    parameters,\n    rules\n  } = ruleSetObject;\n  options.logger?.debug?.(debugId, `Initial EndpointParams: ${toDebugString(endpointParams)}`);\n  const paramsWithDefault = Object.entries(parameters).filter(_ref => {\n    let [, v] = _ref;\n    return v.default != null;\n  }).map(_ref2 => {\n    let [k, v] = _ref2;\n    return [k, v.default];\n  });\n  if (paramsWithDefault.length > 0) {\n    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {\n      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;\n    }\n  }\n  const requiredParams = Object.entries(parameters).filter(_ref3 => {\n    let [, v] = _ref3;\n    return v.required;\n  }).map(_ref4 => {\n    let [k] = _ref4;\n    return k;\n  });\n  for (const requiredParam of requiredParams) {\n    if (endpointParams[requiredParam] == null) {\n      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);\n    }\n  }\n  const endpoint = evaluateRules(rules, {\n    endpointParams,\n    logger,\n    referenceRecord: {}\n  });\n  if (options.endpointParams?.Endpoint) {\n    try {\n      const givenEndpoint = new URL(options.endpointParams.Endpoint);\n      const {\n        protocol,\n        port\n      } = givenEndpoint;\n      endpoint.url.protocol = protocol;\n      endpoint.url.port = port;\n    } catch (e) {}\n  }\n  options.logger?.debug?.(debugId, `Resolved endpoint: ${toDebugString(endpoint)}`);\n  return endpoint;\n};","map":{"version":3,"names":["debugId","toDebugString","EndpointError","evaluateRules","resolveEndpoint","ruleSetObject","options","endpointParams","logger","parameters","rules","debug","paramsWithDefault","Object","entries","filter","v","default","map","k","length","paramKey","paramDefaultValue","requiredParams","required","requiredParam","endpoint","referenceRecord","Endpoint","givenEndpoint","URL","protocol","port","url","e"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js"],"sourcesContent":["import { debugId, toDebugString } from \"./debug\";\nimport { EndpointError } from \"./types\";\nimport { evaluateRules } from \"./utils\";\nexport const resolveEndpoint = (ruleSetObject, options) => {\n    const { endpointParams, logger } = options;\n    const { parameters, rules } = ruleSetObject;\n    options.logger?.debug?.(debugId, `Initial EndpointParams: ${toDebugString(endpointParams)}`);\n    const paramsWithDefault = Object.entries(parameters)\n        .filter(([, v]) => v.default != null)\n        .map(([k, v]) => [k, v.default]);\n    if (paramsWithDefault.length > 0) {\n        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {\n            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;\n        }\n    }\n    const requiredParams = Object.entries(parameters)\n        .filter(([, v]) => v.required)\n        .map(([k]) => k);\n    for (const requiredParam of requiredParams) {\n        if (endpointParams[requiredParam] == null) {\n            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);\n        }\n    }\n    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });\n    if (options.endpointParams?.Endpoint) {\n        try {\n            const givenEndpoint = new URL(options.endpointParams.Endpoint);\n            const { protocol, port } = givenEndpoint;\n            endpoint.url.protocol = protocol;\n            endpoint.url.port = port;\n        }\n        catch (e) {\n        }\n    }\n    options.logger?.debug?.(debugId, `Resolved endpoint: ${toDebugString(endpoint)}`);\n    return endpoint;\n};\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,aAAa,QAAQ,SAAS;AAChD,SAASC,aAAa,QAAQ,SAAS;AACvC,SAASC,aAAa,QAAQ,SAAS;AACvC,OAAO,MAAMC,eAAe,GAAG,CAACC,aAAa,EAAEC,OAAO,KAAK;EACvD,MAAM;IAAEC,cAAc;IAAEC;EAAO,CAAC,GAAGF,OAAO;EAC1C,MAAM;IAAEG,UAAU;IAAEC;EAAM,CAAC,GAAGL,aAAa;EAC3CC,OAAO,CAACE,MAAM,EAAEG,KAAK,GAAGX,OAAO,EAAG,2BAA0BC,aAAa,CAACM,cAAc,CAAE,EAAC,CAAC;EAC5F,MAAMK,iBAAiB,GAAGC,MAAM,CAACC,OAAO,CAACL,UAAU,CAAC,CAC/CM,MAAM,CAAC;IAAA,IAAC,GAAGC,CAAC,CAAC;IAAA,OAAKA,CAAC,CAACC,OAAO,IAAI,IAAI;EAAA,EAAC,CACpCC,GAAG,CAAC;IAAA,IAAC,CAACC,CAAC,EAAEH,CAAC,CAAC;IAAA,OAAK,CAACG,CAAC,EAAEH,CAAC,CAACC,OAAO,CAAC;EAAA,EAAC;EACpC,IAAIL,iBAAiB,CAACQ,MAAM,GAAG,CAAC,EAAE;IAC9B,KAAK,MAAM,CAACC,QAAQ,EAAEC,iBAAiB,CAAC,IAAIV,iBAAiB,EAAE;MAC3DL,cAAc,CAACc,QAAQ,CAAC,GAAGd,cAAc,CAACc,QAAQ,CAAC,IAAIC,iBAAiB;IAC5E;EACJ;EACA,MAAMC,cAAc,GAAGV,MAAM,CAACC,OAAO,CAACL,UAAU,CAAC,CAC5CM,MAAM,CAAC;IAAA,IAAC,GAAGC,CAAC,CAAC;IAAA,OAAKA,CAAC,CAACQ,QAAQ;EAAA,EAAC,CAC7BN,GAAG,CAAC;IAAA,IAAC,CAACC,CAAC,CAAC;IAAA,OAAKA,CAAC;EAAA,EAAC;EACpB,KAAK,MAAMM,aAAa,IAAIF,cAAc,EAAE;IACxC,IAAIhB,cAAc,CAACkB,aAAa,CAAC,IAAI,IAAI,EAAE;MACvC,MAAM,IAAIvB,aAAa,CAAE,gCAA+BuB,aAAc,GAAE,CAAC;IAC7E;EACJ;EACA,MAAMC,QAAQ,GAAGvB,aAAa,CAACO,KAAK,EAAE;IAAEH,cAAc;IAAEC,MAAM;IAAEmB,eAAe,EAAE,CAAC;EAAE,CAAC,CAAC;EACtF,IAAIrB,OAAO,CAACC,cAAc,EAAEqB,QAAQ,EAAE;IAClC,IAAI;MACA,MAAMC,aAAa,GAAG,IAAIC,GAAG,CAACxB,OAAO,CAACC,cAAc,CAACqB,QAAQ,CAAC;MAC9D,MAAM;QAAEG,QAAQ;QAAEC;MAAK,CAAC,GAAGH,aAAa;MACxCH,QAAQ,CAACO,GAAG,CAACF,QAAQ,GAAGA,QAAQ;MAChCL,QAAQ,CAACO,GAAG,CAACD,IAAI,GAAGA,IAAI;IAC5B,CAAC,CACD,OAAOE,CAAC,EAAE,CACV;EACJ;EACA5B,OAAO,CAACE,MAAM,EAAEG,KAAK,GAAGX,OAAO,EAAG,sBAAqBC,aAAa,CAACyB,QAAQ,CAAE,EAAC,CAAC;EACjF,OAAOA,QAAQ;AACnB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}