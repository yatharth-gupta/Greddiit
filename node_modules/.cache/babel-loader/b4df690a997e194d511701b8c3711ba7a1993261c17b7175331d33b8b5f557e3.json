{"ast":null,"code":"import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n  const MAX_CAPACITY = initialRetryTokens;\n  const retryCost = options?.retryCost ?? RETRY_COST;\n  const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n  const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();\n  let availableCapacity = initialRetryTokens;\n  let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n  let lastRetryCost = undefined;\n  let retryCount = initialRetryCount ?? 0;\n  const getCapacityAmount = errorType => errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost;\n  const getRetryCount = () => retryCount;\n  const getRetryDelay = () => retryDelay;\n  const getLastRetryCost = () => lastRetryCost;\n  const hasRetryTokens = errorType => getCapacityAmount(errorType) <= availableCapacity;\n  const getRetryTokenCount = errorInfo => {\n    const errorType = errorInfo.errorType;\n    if (!hasRetryTokens(errorType)) {\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(errorType);\n    const delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n    retryBackoffStrategy.setDelayBase(delayBase);\n    const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n    if (errorInfo.retryAfterHint) {\n      const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n    } else {\n      retryDelay = delayFromErrorType;\n    }\n    retryCount++;\n    lastRetryCost = capacityAmount;\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  const releaseRetryTokens = releaseAmount => {\n    availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return {\n    getRetryCount,\n    getRetryDelay,\n    getLastRetryCost,\n    hasRetryTokens,\n    getRetryTokenCount,\n    releaseRetryTokens\n  };\n};","map":{"version":3,"names":["DEFAULT_RETRY_DELAY_BASE","MAXIMUM_RETRY_DELAY","NO_RETRY_INCREMENT","RETRY_COST","THROTTLING_RETRY_DELAY_BASE","TIMEOUT_RETRY_COST","getDefaultRetryBackoffStrategy","getDefaultRetryToken","initialRetryTokens","initialRetryDelay","initialRetryCount","options","MAX_CAPACITY","retryCost","timeoutRetryCost","retryBackoffStrategy","availableCapacity","retryDelay","Math","min","lastRetryCost","undefined","retryCount","getCapacityAmount","errorType","getRetryCount","getRetryDelay","getLastRetryCost","hasRetryTokens","getRetryTokenCount","errorInfo","Error","capacityAmount","delayBase","setDelayBase","delayFromErrorType","computeNextBackoffDelay","retryAfterHint","delayFromRetryAfterHint","getTime","Date","now","max","releaseRetryTokens","releaseAmount"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js"],"sourcesContent":["import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n    const MAX_CAPACITY = initialRetryTokens;\n    const retryCost = options?.retryCost ?? RETRY_COST;\n    const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n    const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();\n    let availableCapacity = initialRetryTokens;\n    let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n    let lastRetryCost = undefined;\n    let retryCount = initialRetryCount ?? 0;\n    const getCapacityAmount = (errorType) => (errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost);\n    const getRetryCount = () => retryCount;\n    const getRetryDelay = () => retryDelay;\n    const getLastRetryCost = () => lastRetryCost;\n    const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;\n    const getRetryTokenCount = (errorInfo) => {\n        const errorType = errorInfo.errorType;\n        if (!hasRetryTokens(errorType)) {\n            throw new Error(\"No retry token available\");\n        }\n        const capacityAmount = getCapacityAmount(errorType);\n        const delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n        retryBackoffStrategy.setDelayBase(delayBase);\n        const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n        if (errorInfo.retryAfterHint) {\n            const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n            retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n        }\n        else {\n            retryDelay = delayFromErrorType;\n        }\n        retryCount++;\n        lastRetryCost = capacityAmount;\n        availableCapacity -= capacityAmount;\n        return capacityAmount;\n    };\n    const releaseRetryTokens = (releaseAmount) => {\n        availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n    };\n    return {\n        getRetryCount,\n        getRetryDelay,\n        getLastRetryCost,\n        hasRetryTokens,\n        getRetryTokenCount,\n        releaseRetryTokens,\n    };\n};\n"],"mappings":"AAAA,SAASA,wBAAwB,EAAEC,mBAAmB,EAAEC,kBAAkB,EAAEC,UAAU,EAAEC,2BAA2B,EAAEC,kBAAkB,QAAS,aAAa;AAC7J,SAASC,8BAA8B,QAAQ,+BAA+B;AAC9E,OAAO,MAAMC,oBAAoB,GAAG,CAACC,kBAAkB,EAAEC,iBAAiB,EAAEC,iBAAiB,EAAEC,OAAO,KAAK;EACvG,MAAMC,YAAY,GAAGJ,kBAAkB;EACvC,MAAMK,SAAS,GAAGF,OAAO,EAAEE,SAAS,IAAIV,UAAU;EAClD,MAAMW,gBAAgB,GAAGH,OAAO,EAAEG,gBAAgB,IAAIT,kBAAkB;EACxE,MAAMU,oBAAoB,GAAGJ,OAAO,EAAEI,oBAAoB,IAAIT,8BAA8B,EAAE;EAC9F,IAAIU,iBAAiB,GAAGR,kBAAkB;EAC1C,IAAIS,UAAU,GAAGC,IAAI,CAACC,GAAG,CAAClB,mBAAmB,EAAEQ,iBAAiB,CAAC;EACjE,IAAIW,aAAa,GAAGC,SAAS;EAC7B,IAAIC,UAAU,GAAGZ,iBAAiB,IAAI,CAAC;EACvC,MAAMa,iBAAiB,GAAIC,SAAS,IAAMA,SAAS,KAAK,WAAW,GAAGV,gBAAgB,GAAGD,SAAU;EACnG,MAAMY,aAAa,GAAG,MAAMH,UAAU;EACtC,MAAMI,aAAa,GAAG,MAAMT,UAAU;EACtC,MAAMU,gBAAgB,GAAG,MAAMP,aAAa;EAC5C,MAAMQ,cAAc,GAAIJ,SAAS,IAAKD,iBAAiB,CAACC,SAAS,CAAC,IAAIR,iBAAiB;EACvF,MAAMa,kBAAkB,GAAIC,SAAS,IAAK;IACtC,MAAMN,SAAS,GAAGM,SAAS,CAACN,SAAS;IACrC,IAAI,CAACI,cAAc,CAACJ,SAAS,CAAC,EAAE;MAC5B,MAAM,IAAIO,KAAK,CAAC,0BAA0B,CAAC;IAC/C;IACA,MAAMC,cAAc,GAAGT,iBAAiB,CAACC,SAAS,CAAC;IACnD,MAAMS,SAAS,GAAGT,SAAS,KAAK,YAAY,GAAGpB,2BAA2B,GAAGJ,wBAAwB;IACrGe,oBAAoB,CAACmB,YAAY,CAACD,SAAS,CAAC;IAC5C,MAAME,kBAAkB,GAAGpB,oBAAoB,CAACqB,uBAAuB,CAACd,UAAU,CAAC;IACnF,IAAIQ,SAAS,CAACO,cAAc,EAAE;MAC1B,MAAMC,uBAAuB,GAAGR,SAAS,CAACO,cAAc,CAACE,OAAO,EAAE,GAAGC,IAAI,CAACC,GAAG,EAAE;MAC/ExB,UAAU,GAAGC,IAAI,CAACwB,GAAG,CAACJ,uBAAuB,IAAI,CAAC,EAAEH,kBAAkB,CAAC;IAC3E,CAAC,MACI;MACDlB,UAAU,GAAGkB,kBAAkB;IACnC;IACAb,UAAU,EAAE;IACZF,aAAa,GAAGY,cAAc;IAC9BhB,iBAAiB,IAAIgB,cAAc;IACnC,OAAOA,cAAc;EACzB,CAAC;EACD,MAAMW,kBAAkB,GAAIC,aAAa,IAAK;IAC1C5B,iBAAiB,IAAI4B,aAAa,IAAI1C,kBAAkB;IACxDc,iBAAiB,GAAGE,IAAI,CAACC,GAAG,CAACH,iBAAiB,EAAEJ,YAAY,CAAC;EACjE,CAAC;EACD,OAAO;IACHa,aAAa;IACbC,aAAa;IACbC,gBAAgB;IAChBC,cAAc;IACdC,kBAAkB;IAClBc;EACJ,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}