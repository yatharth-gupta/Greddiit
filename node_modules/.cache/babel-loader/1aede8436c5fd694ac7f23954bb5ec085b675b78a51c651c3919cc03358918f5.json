{"ast":null,"code":"import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nexport class FetchHttpHandler {\n  constructor(options) {\n    if (typeof options === \"function\") {\n      this.configProvider = options().then(opts => opts || {});\n    } else {\n      this.config = options ?? {};\n      this.configProvider = Promise.resolve(this.config);\n    }\n  }\n  destroy() {}\n  async handle(request) {\n    let {\n      abortSignal\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.config) {\n      this.config = await this.configProvider;\n    }\n    const requestTimeoutInMs = this.config.requestTimeout;\n    if (abortSignal?.aborted) {\n      const abortError = new Error(\"Request aborted\");\n      abortError.name = \"AbortError\";\n      return Promise.reject(abortError);\n    }\n    let path = request.path;\n    if (request.query) {\n      const queryString = buildQueryString(request.query);\n      if (queryString) {\n        path += `?${queryString}`;\n      }\n    }\n    const {\n      port,\n      method\n    } = request;\n    const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n    const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n    const requestOptions = {\n      body,\n      headers: new Headers(request.headers),\n      method: method\n    };\n    if (typeof AbortController !== \"undefined\") {\n      requestOptions[\"signal\"] = abortSignal;\n    }\n    const fetchRequest = new Request(url, requestOptions);\n    const raceOfPromises = [fetch(fetchRequest).then(response => {\n      const fetchHeaders = response.headers;\n      const transformedHeaders = {};\n      for (const pair of fetchHeaders.entries()) {\n        transformedHeaders[pair[0]] = pair[1];\n      }\n      const hasReadableStream = response.body !== undefined;\n      if (!hasReadableStream) {\n        return response.blob().then(body => ({\n          response: new HttpResponse({\n            headers: transformedHeaders,\n            statusCode: response.status,\n            body\n          })\n        }));\n      }\n      return {\n        response: new HttpResponse({\n          headers: transformedHeaders,\n          statusCode: response.status,\n          body: response.body\n        })\n      };\n    }), requestTimeout(requestTimeoutInMs)];\n    if (abortSignal) {\n      raceOfPromises.push(new Promise((resolve, reject) => {\n        abortSignal.onabort = () => {\n          const abortError = new Error(\"Request aborted\");\n          abortError.name = \"AbortError\";\n          reject(abortError);\n        };\n      }));\n    }\n    return Promise.race(raceOfPromises);\n  }\n}","map":{"version":3,"names":["HttpResponse","buildQueryString","requestTimeout","FetchHttpHandler","constructor","options","configProvider","then","opts","config","Promise","resolve","destroy","handle","request","abortSignal","requestTimeoutInMs","aborted","abortError","Error","name","reject","path","query","queryString","port","method","url","protocol","hostname","body","undefined","requestOptions","headers","Headers","AbortController","fetchRequest","Request","raceOfPromises","fetch","response","fetchHeaders","transformedHeaders","pair","entries","hasReadableStream","blob","statusCode","status","push","onabort","race"],"sources":["/home/yatharth/Desktop/sem_4/DASS/assignment_1/my-app/node_modules/@aws-sdk/fetch-http-handler/dist-es/fetch-http-handler.js"],"sourcesContent":["import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nexport class FetchHttpHandler {\n    constructor(options) {\n        if (typeof options === \"function\") {\n            this.configProvider = options().then((opts) => opts || {});\n        }\n        else {\n            this.config = options ?? {};\n            this.configProvider = Promise.resolve(this.config);\n        }\n    }\n    destroy() {\n    }\n    async handle(request, { abortSignal } = {}) {\n        if (!this.config) {\n            this.config = await this.configProvider;\n        }\n        const requestTimeoutInMs = this.config.requestTimeout;\n        if (abortSignal?.aborted) {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            return Promise.reject(abortError);\n        }\n        let path = request.path;\n        if (request.query) {\n            const queryString = buildQueryString(request.query);\n            if (queryString) {\n                path += `?${queryString}`;\n            }\n        }\n        const { port, method } = request;\n        const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n        const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n        const requestOptions = {\n            body,\n            headers: new Headers(request.headers),\n            method: method,\n        };\n        if (typeof AbortController !== \"undefined\") {\n            requestOptions[\"signal\"] = abortSignal;\n        }\n        const fetchRequest = new Request(url, requestOptions);\n        const raceOfPromises = [\n            fetch(fetchRequest).then((response) => {\n                const fetchHeaders = response.headers;\n                const transformedHeaders = {};\n                for (const pair of fetchHeaders.entries()) {\n                    transformedHeaders[pair[0]] = pair[1];\n                }\n                const hasReadableStream = response.body !== undefined;\n                if (!hasReadableStream) {\n                    return response.blob().then((body) => ({\n                        response: new HttpResponse({\n                            headers: transformedHeaders,\n                            statusCode: response.status,\n                            body,\n                        }),\n                    }));\n                }\n                return {\n                    response: new HttpResponse({\n                        headers: transformedHeaders,\n                        statusCode: response.status,\n                        body: response.body,\n                    }),\n                };\n            }),\n            requestTimeout(requestTimeoutInMs),\n        ];\n        if (abortSignal) {\n            raceOfPromises.push(new Promise((resolve, reject) => {\n                abortSignal.onabort = () => {\n                    const abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n            }));\n        }\n        return Promise.race(raceOfPromises);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}